同步:
1、给对象加锁，锁语句可可以产生一种互相排斥的效果，这种机制常常称为互斥量。
2、java的synchronized关键字，为防止资源冲突提供了内置支持，当任务要执行被synchronized关键子保护的代码片段时，
    它将检查锁是否可用，然后获取锁，执行代码，释放锁。
3、共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或打印机。 要控制对共享资源的访问，得先把它包装进一个对象，然后
    把所有要访问这个资源的方法标记为synchronized，如果不一个任务处于一个对标记为synchronized的方法调用中，那么在这个线程从该方法返回之前，其它所有
    调用类中任何标记为synchronized方法的线程都会被阻塞,所以可以把方法标记为synchronized来防止资源冲突，如：
   public synchronized void f(){};
   public synchronized void g(){};   //在某一线程调用f()方法时，其它想调用synchronized关键字的g()方法的线程将被阻塞,直到f()方法执行完且释放
   锁，g()方法才能被其它线程调用.
   尽量将对象内的变量设为private，同一个线程可以在同一个对象上多次获得锁，如：在调用对象上的A方法时（得到了锁），其同时可调用对象上的B,C有synchronized
   关键字的方法，这时对象被加锁的次数将会增加，直接调用完方法返回，锁的计划变为0，这时表示释放了对象上的锁。
4、针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问。
   如果一个类中有超过一个方法在处理临界数据，那么你必须同步所有相关方法。每个访问临界共享资源的方法都必须被同步，否则它们不会正确地工作。
 
原子性与易变性
1、原子操作是不能被线程调度机制中断的操作，且在进行上下文切换之前操作一定会执行完毕。
2、原子性可以应用于除long和double之外的所有基本类型之上的“简单操作”，因为JVM可以将64位的读取与写入当作两个分离的32位操作来执行，这会产生在一个读
   取和定入操作中间发生上下文切换，会出现“字撕裂”的情况。但如果定义long与double变量时，使用volatile关键字，就会获得原子性。
3、volatile关键字定义的域与synchronized定义的同步方法与代码块的在有写入或更新时，会立即将结果刷新到主存中，其它任务可以即时看到最新内容
     ，而非volatile与synchronized的方法或代码块则不会更新主存，那么其它任务就看不到最新内容。
  如果一个域完全由synchronized方法或语句块来防护，就不必将其设置为是volatile的.
4、对域中的值做赋值和返回操作通常都是原子性的。java中的递增/减操作不是原子性的，当域用volatile定义时，编译器将不会对此域进行读取或写入上的优化，以
    保证对他的操作都是原子性的。此时读取和写入都是直接针对内存，没有被缓存。
5、AtomicLong,AtomicInteger,atomicReference等特殊的原子性变量类，它位提供下面形式的原子性条件更新操作：
   boolean compareAndSet(expectedValue,updateValue);
   对于常规编程来说，它们很少会派上用场，但涉及性能调忧时，它们就大有用武之地。Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才
   在自己的代码中使用它们，即便使用了也需要确保不存在其他可能出现的问题，通常依赖锁更安全些（如：synchronized关键字，显示的Lock对象）
   
 临界区：
 1、被synchronized花括号包起来的代码称为临界区，他用来锁定对象中的某部分代码块，而不是整个方法。用synchronized括起的代码也称：同步控制块.这种
      减少代码范围的控制块，可以使多个任务访问对象的时间性能得到显著提高。
    如: synchronized(synchObject){  //获得当前对象的锁
        //other code....
    }
 2、在其他对象上同步：
    synchronized块必须给定一个在其上进行同步的对象，并且是最合理的方式是，使用其方法正在调用的当前对象：synchronized(this)，在这种方式中，如果
      获得了synchronized块上的锁，那么该对象其他的synchronized方法和临界区就不能被调用了，因此，如果在this上同步，临界区的效果就会直接缩小在同步的
     范围内，有时必须在另一个对象上同步，如果这么做，就必须确保所有相关的任务都是在同一个对象上同步。两个任务可以同时进入同一个对象，只要对象上的方法
     是在不同的锁上同步即可，即：有任务A和B,对象上有两个同步块，一个是方法，一个是同步代码块，方法的锁对象是this，同步块的锁是另一个对象synchobject，
     这时A和B都不会阻塞，他们可以同时访问this锁和synchojbect锁的代码.
     
 3、线程本地存储：  防止任务在共享资源上产生冲突的第二种方式是根除对变更的共享。线程本地存储是一种自动化机制，可以为使用相同变更的每个不同的线程
     都创建不同的存储。即：当5个线程要用的x变量，线程本地存储就会生成5个用于x的不同的存储块，可以将状态与线程关联起来。见demo:ThreadLocalVariableHolder.java
     
     
 4、终止、取消、关闭任务、中断
    取消： 通过自己设置标志对线程进行判断来取消；   用ExecutorService的shutDown来终止任务，
  检测任务是否在期待时间内结束。ExecutorService.awitTermination(250,TimeUnit.SECONDS);在时间范围内返回true,不是的返回false;
  sleep(50) 方法只能让线程阻塞，最终将会被唤醒。线程一般有以下几种状态：
  新建（new)： 此状态相对短暂，分配资源，执行初始化，有资格获得时间片，等调度器调度其为运行或阻塞状态.
  就绪（Runnable)： 万事具备，只欠东风。此状态下，只要调度器将时间分配线程，线程就可以运行。
  阻塞（Blocked)： 线程能够运行，但某个条件阻止它的运行，此状态下，调度器将忽略线程，不分配时间片，直到进入就绪状态，才会执行调度操作。
  死亡(Dead): 处于死亡或终止状态的线程将不可再调度，也不会得到时间，表示任务已结束或不再是运行的。任务死亡方式通过方式是从run方法返回，但是
   线程还可以被中断（interrupted)。
 
 进入阻塞状态的原因：
 a、调用sleep(milliseconds)使任务进入休眠状态，在指定时间内任务不会运行；
 b、通过调用wait()使线程挂起，直到线程得到了notify或notifyAll消息（jdk1.5后java.util.concurrent库中有等价的signal()或signalAll()消息）,线程才会进入就绪状态;
 c、任务在等待某个输入/输出完成;
 d、任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁;
 
 如何终止阻塞中的任务：用中断来实现
 中断的意思就是：在Runnable.run()方法中间打断它，这时可能要清理资源，比较麻烦，在任务的run方法中间打断，更像是抛出异常，在java线程中的这种类型的异常中断
 中用到了异常，当以这种方式结束任务时，要想返回良好状态，要注意编写catch子句以正确清除所有事物。
 
 Thread中的interrupt()方法，可以终止被阻塞的任务，这个方法将设置线程的中断状态，对阻塞的线程或试图执行一个阻塞操作，那么设置这个线程的中断状态将
 抛出InterruptedException。当抛出异常或该任务调用Thread.interrupted()时，中断状态将被复位。Thread.interrupted()提供了离开run循环而不抛出异常的第二种方式。
 
 
 要想调用interrupt()方法，得有Thread对象，在jdk并发库中，已避免直接对Thread进行操作，当用Executor来执行操作时，当调用shutdownNow()方法，那么它将发送一个
 interrupt()调用给它启动的所有线程，来中断所有线程。当要中断一个线程时，在用Executor启动线程时要用submit()来启动，而非executor()来启动，此时才能取得当前
 任务的上下文，submit()将返回一个Future<?>，有了这个Future就可以调用其cancel()，来将true传递给cancel()，那么就有可以在当前线程中调用interrupt()以停止
 线程的权限。所以，cancel()是一种中断由Executor启动的单个线程的方式.
 IO阻塞和正在获取同步块锁的代码不能直接用Thread.interrupt()中断任务,而要先将流关闭流
 即：exec.shutdownNow(); in.close();out.close();这是通过关闭任务在其上发生阻塞的底层资源来实现的.在nio中提供了更人性化的i/O中断，被阻塞的nio通道会自动响应
 中断。见: NIOInterruption.java；一个获得了对象锁的线程可以获得当前对象中所有有同步关键字(synchronized)的方法或代码块的锁,他们可以相互调用。
 
 用jdk1.5后拼发类库中的ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或临界区上阻塞的任务完全不同。见代码:Interrupting2.java
 Thread.currentThread.interrupt()用来设置线程的中断状态，将Thread.interrupted设为ture,此时会抛出InterruptedException.此时要在try-finally中清理资源
 ，Thread.interrupted()用来得到当前线程的状态（true/false)，以此确定线程是否中断。
 
 
 线程之间的协作:
 通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。
 多个任务彼此之间协作可以一起去解决某个问题，通过彼此的协调来将大问题分解为小问题的任务各自完成，最后结果是正确的。
 当任务协作时，关键是任务之间的握手，一样可以通过基础特性“互斥”来解决，确保只有一个任务可以响应某个信息，这可根据任何可能的竞争条件，这种机制称为：挂起。
 直至某些外部条件发生变化，表示是时候让这个任务向前开动了为止。这种握手可能通过Object的方法wait()和notify()来完全地实现，JavaSE5中的并发库提供了具有:
 await()和signal()方法的Condition对象.
 
 
 Object.wait():将当前线程挂起，并释放已获得的锁，在别人Object.notify或notifyAll时或wait的时间到期，会再取得锁，继续wait后台的任务代码.
 sleep()和yeild()时并没有释放锁.
 wait(),notify()和notifyAll()只能在同步控制方法或同步控制块里调用 ，因为要获得当前对象的锁，即在synchronized代码中已经得到了一个锁ID，那么在wait()时知道当前
 是哪个锁，同样在notify或notifyAll时他也要知道是哪个对象的哪个锁ID，而在wait时记下了锁ID，notify时才会回到wait时那个锁的ID那里去.
 一般在wiat()方法外围用while循环来进行进行检查条件是否满足，如果不满足刚继续等待。
 
 
 使用显示的Lock和Condition对象:
 Java SE5的java.util.concurrent库，使用互斥并允许任务挂起的基本类是Condition，可以用Condition上的await()挂起一个任务，当外部条件发生变化，意味着某个
 任务应该继续执行时，可用调用 signal()来通知这个任务，从而唤醒一个任务，或调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务。signalAll比notifyAll
 更安全，详列见：WaxOmatic.java(给车刨光和打两次蜡)
 
 生产者--消费者之阻塞队列(同步队列)实现：可以用concurrent库中的BlockingQueue，它有三种实现:LinkedBlockingQueue(不限大小,无界队列）
 ，ArrayBlockingQueen(固定大小)，SynchronousQueue（一个元素）,可以使用以上同步队列解决任务协作问题，比notify和notifyAll更简单，同步队列任何时刻都只允许
 一个任务插入或移除元素，如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素可用时恢复消费者任务，
 阻塞队列比wait和notifyAll相比，更简单可靠。见例子TestBlockingQueues.java.阻塞队列可以实现同步及协作控制，比用原生的语法wait、notify、synchronized要
 方便简单的多，这些要求都在BlockingQueue中实现了，任何时刻只有一个任务可以访问队列中的元素，处理过程中将被自动地挂起和恢复。见例：Toast0Matic.java
 
 任务间管理的输入/输出
 通过输入/输出在线程间进行通信通常很有用，java中的输入/输出类库：PipedWriter(允许任务向管道写)/PipedReader(允许不同任务从同一个管道中读取)，对线程间以
 “管道”形式进行输入/输出提供了支持，它可以说是"生产者--消费者"的变体，见例子：PipedIO.java.PipedReader与普通I/O这间最重要的差异是---PipedReader
 是可以中断的，而普通I/O是不行的，需要调用相应流的close()方法后，才能中断。
 
 死锁的4个条件：
 1、互斥条件。任务使用的资源中至少有一个是不能共享的。
 2、至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。
 3、资源不能被任务抢占，任务必须把资源释放当作普通事件。（即条件上不允许强制抢，只准文明等待，按规则来，如排队一样)
 4、必须有循环等待。A等B，B等C，C又在等A.  见例子：FixedDiningPhilosophers.java。哲学家思考和吃饭问题
 
 新类库中的构件: java.util.concurrent(用此库中的新类，有助于编写出更加简单而健壮的并发程序）
 1、CountDownLatch:   它被用来同步一个或多个任务，强制它们等待由其他任务执行的一级操作完成。可以为这个对像设置一个初始值（如：5），表示他将等5个任务执行完
    （或不在任务下，手工调用countDown方法减少数值大小）每一个任务完成可调用一次countDown，一直countDown到最被设的值由5变为0。
    在countDown为0之前，其将一直等待。其有await()方法，当countDown为0时，其将会自动唤醒。完成任务。如：用CountdownLatch来解决将一个程序分为n个互相独立的
    任务，并创建值为100的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown().等待问题被解决的任务在这个锁存器上调用await()，将它们
    自己拦住，直至锁存器结束。CounDownLatch只能触发一次，计数值不能重置。
   简单解说：A任务分解为A1---A50个子任务，B任务要等A任务全部解决才能继续。那么解决A任务的线程可以调用countDown，然后B任务一直等待(await)countDown后为0，
   再执行任务B.
   见CountDownLatchDemo.java
2、CyclicBarrier: 适用于这样的情况：你希望创建一组任务，它们并行的执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。
   即：A B C D任务 要全部完成，方能进入E任务，相当于工作流的并行网关，所有任务到达后才能出网关。CyclicBarrier需要一个“栅栏动作”，
    用以拦截所有需要汇合的任务，和CountDownLatch不同的时，它可以触发多次。见例子：HorseRace.java 这是一个赛马的例子，在所有马都跑完后，在栅栏处打印马匹信息.
  所有线程到达栅栏处后只要不调用shutdownNow，CyclicBarrier还会再次触发事件（继续让马跑).
     
3、DelayQueue:延迟队列,这也是一个BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在期时才能从队列中取走，队列有序，队头对象的延迟
    时间最长，如果没有任何延迟到期，那么就不会有任务头元素（全消费了），并且poll()将返回null.不能保存null，继承了Delayed对象的对象本身就是任务，
    见例子：DelayQueueDemo.java
    
4、PriorityBlockingQueue: 优先级阻塞队列,具有可阻塞的读取操作，队列中的对象按照优先级顺序从队列中出现的任务，被赋予了一个优先级数字。
     作为优先级阻塞队列中的任务对象要实现Runnable和Comparable接口， 即：实现run方法，实现compareTo()来比较任务的优先级。在构造此任务时要传入
     priority（优先级比较参数），再在compareTo()方法中使用。以排序。例子见：PriorityBlockingQueueDemo.java,PriorityBlockingQueue队列，特性中其提供了
     所有必需的同步，使用时不需要任何显式的同步，不必考虑当你从这种队列中读取时，其中是否有元素，因为这个队列在没有元素时，将直接阻塞读取者。
5、ScheduledThreadPoolExecutor： 可调度线程池执行器：可以用其schedule()方法，只运行一次一任务；也可以用scheduleAtFixedRate()方法每隔规则时间
        重复执行任务，即将Runnable对象设置为在将来某个时刻执行。(730练习)
6、Semaphore: 计数信号量。其允许多个任务同时访问这个资源，可将其看作是向外分发使用资源的“许可证”，可用Semaphore的acquire()来签出对象，用release()
        签入对象。典型的应用是对象池。它管理着有限的对象，使用时可签出对象，使用完毕可签回，见例子：SemaphoreDemo.java
7、Exchanger : 两个任务之间交换对象的栅栏（生产--消费），当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都是拥有之前由对象持有的对象。
		其典型应用场景是：一个任务在创建对象，这些对象的生产代价很高昂，而中一个任务在消费这些对象。通过这种方式可以有更多的的对象在被创建的同时被消费.
		2个任务交换对象，空的变实的，实的变空的。见736. 737
8、SynchronousQueue:  无元素阻塞队列，即手手相传。要put时要等take来再放，同样，要take时要等到put时才拿，没有中间缓冲区。见:741,747

9、免锁容器： CopyOnWriteArrayList/CopyOnWriteArraySet/ConcurrentHashMap/ConcurrentLinkedQueue.
     此种容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分
     的一个单独的副本（有时是整个数据库结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会
     自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。如：在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组
     将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行，当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新
     的修改。CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。CopyOnWriteArraySet
     将使用CopyOnWriteArrayList来实现其免锁行为，ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，
     但是容器中只有部分内容而不是整个容器可以被复制和修改，在修改完成之前，读取者不能看到它们.从免锁容器中读取，比synchronized对应物
     要快许多，因为获取和释放锁的开销被省掉了。CopyOnWriterArrayList比SynchronizedArrayList要快，ConcurrentHashMap比synchronizedMap要快.
     
 10、乐观加锁：Atomic对象可以执行decrementAndGet()这样的原子性操作，某些Atomic类还允许你执行所谓的“乐观加锁”。即执行计算时，实际上没有使用互斥，但
         计算完成后，并准备更新这个atomic对象时，需要使用一个称为compareAndSet()的方法，将旧值和新值一起提交给这个方法，如果旧值与它在Atomic对象中发现
         的值不一致，那么这个操作就失败，这意味着某个其他的任务已经于此操作执行期间修改了这个对象，通过使用Atomic来替代synchronized或Lock，可以获得
         性能上的好处。AtomicInteger[][] grid = new AtomicInteger[3][3];假设都初始化了下面在更新前进行比较:grid[1][1].compareAndSet(oldvalue,newvalue)
     ReadWriteLock:  对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读
       取者，只要它们都不试图写入即可。如果写锁已经被其它任务持有，那么读取者都不能访问，直到这个写锁被释放为止。它是否能提高性能是完全不可确定的，
       它取决于诸如数据读取的频率与被修改的频率相比较的结果，读取和写入操作时间，有多少线程竞争以及是否在多处理机器上运行。见例子：ReaderWriterList.java
 11、活动对象：每个对象都维护着它自己的工作器线程和消息队列，并且所有对这种对象的的请求都将进入队列排队，任何时刻都只能运行其中一个。因些，有了活动对象，
          我们就可以串行化消息而不是方法，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了。当你向一个活动对象发送消息时，这条消息会转变为一个任务，
          该任务会被插入到这个对象的队列中，等待在以后的某个时刻运行。见例子：ActiviteObjectDemo.java
          
 java并发编程实践精要：
 一、如何构造线程安全的类及编写线程安全程序？
    1、可变状态是至关重要的，所有的并发问题都是可以归结为如何协调对并发状态的访问，可变状态越少，就越容易确保线程安全性。即：数据的状态变化，越
    不受线程影响越好，要受影响就可注意各线程之间对数据状态的修改与协调.如果可以尽量将变量定义为:private + final的，将它们设为不可变，不可变对象一
    定是线程安全的，不可变对象能极大地降低并发编程的复杂性，它们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。
    2、好的封装有助于管理复杂性，将数据封装在对象中，更易于维护不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
    3、用锁来保护每个可变变量。
    4、当保护同一个不变性条件中的所有变量时（即变量间的状态相互有约束条件影响），要使用同一个锁.
    5、在执行复杂操作期间（即多个有顺序执行的操作），要持有锁（让这些操作在同步块中一起执行)
    6、如果从多个线程中访问同一个可变变量进没有同步机制，那么程序会出现问题，在设计中明确指出线程是不安全的，且将同步策略文档化。
    7、尽量将线程不安全的封装到底层，用线程安全的方式来访问。
    8、如何取消线程：
       a、自定义取消标志;b、用interrupted来中断;c、用Future来取消任务;d、对于不可中断的阻塞（如：I/O或等锁)方法1:可以继承Thread，重写interrupt()方法
          将要关闭的I/O与任务的中断取消放在一起，方法2：通过newTaskFor取消,见SocketUsingTask.java。
 二、多线程集合库及线程执行框架。
    1、
 
    
    
 
